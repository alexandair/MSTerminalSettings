// https://app.quicktype.io?share=wKnK2rdXtlyK1CYv3ruQ

// <auto-generated />
//
// To parse this JSON data, add NuGet 'Newtonsoft.Json' then do:
//
//    using WindowsTerminal;
//
//    var terminalSettings = TerminalSettings.FromJson(jsonString);

namespace WindowsTerminal
{
    using System;
    using System.Collections.Generic;

    using System.Globalization;
    using Newtonsoft.Json;
    using Newtonsoft.Json.Converters;

    /// <summary>
    /// Properties that affect the entire window, regardless of the profile settings.
    /// </summary>
    public partial class TerminalSettings
    {
        [JsonProperty("profiles", Required = Required.Always)]
        public ProfilesObject Profiles { get; set; }

        [JsonProperty("schemes", Required = Required.Always)]
        public List<SchemeList> Schemes { get; set; }

        /// <summary>
        /// Sets the default profile. Opens by clicking the '+' icon or typing the key binding
        /// assigned to 'newTab'. The guid of the desired default profile is used as the value.
        /// </summary>
        [JsonProperty("defaultProfile", Required = Required.Always)]
        public string DefaultProfile { get; set; }

        /// <summary>
        /// When set to true, tabs are always displayed. When set to false and showTabsInTitlebar is
        /// set to false, tabs only appear after opening a new tab.
        /// </summary>
        [JsonProperty("alwaysShowTabs", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public bool? AlwaysShowTabs { get; set; }

        /// <summary>
        /// When set to `true` closing a window with multiple tabs open WILL require confirmation.
        /// When set to `false` closing a window with multiple tabs open WILL NOT require
        /// confirmation.
        /// </summary>
        [JsonProperty("confirmCloseAllTabs", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public bool? ConfirmCloseAllTabs { get; set; }

        /// <summary>
        /// When set to true, a selection is immediately copied to your clipboard upon creation. When
        /// set to false, the selection persists and awaits further action.
        /// </summary>
        [JsonProperty("copyOnSelect", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public bool? CopyOnSelect { get; set; }

        /// <summary>
        /// The number of columns displayed in the window upon first load.
        /// </summary>
        [JsonProperty("initialCols", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public long? InitialCols { get; set; }

        /// <summary>
        /// The position of the top left corner of the window upon first load. On a system with
        /// multiple displays, these coordinates are relative to the top left of the primary display.
        /// If launchMode is set to maximized, the window will be maximized on the monitor specified
        /// by those coordinates.
        /// </summary>
        [JsonProperty("initialPosition", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public string InitialPosition { get; set; }

        /// <summary>
        /// The number of rows displayed in the window upon first load.
        /// </summary>
        [JsonProperty("initialRows", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public long? InitialRows { get; set; }

        /// <summary>
        /// Properties are specific to each custom key binding.
        /// </summary>
        [JsonProperty("keybindings", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public List<Keybinding> Keybindings { get; set; }

        /// <summary>
        /// Defines whether the Terminal will launch as maximized or not.
        /// </summary>
        [JsonProperty("launchMode", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public LaunchMode? LaunchMode { get; set; }

        /// <summary>
        /// Sets the theme of the application.
        /// </summary>
        [JsonProperty("requestedTheme", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public RequestedTheme? RequestedTheme { get; set; }

        /// <summary>
        /// The number of rows to scroll at a time with the mouse wheel. This will override the
        /// system setting if the value is not zero or 'system'.
        /// </summary>
        [JsonProperty("rowsToScroll", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public RowsToScroll? RowsToScroll { get; set; }

        /// <summary>
        /// When set to true, the tabs are moved into the titlebar and the titlebar disappears. When
        /// set to false, the titlebar sits above the tabs.
        /// </summary>
        [JsonProperty("showTabsInTitlebar", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public bool? ShowTabsInTitlebar { get; set; }

        /// <summary>
        /// When set to true, titlebar displays the title of the selected tab. When set to false,
        /// titlebar displays 'Windows Terminal'.
        /// </summary>
        [JsonProperty("showTerminalTitleInTitlebar", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public bool? ShowTerminalTitleInTitlebar { get; set; }

        /// <summary>
        /// When set to true, the window will snap to the nearest character boundary on resize. When
        /// false, the window will resize 'smoothly'
        /// </summary>
        [JsonProperty("snapToGridOnResize", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public bool? SnapToGridOnResize { get; set; }

        /// <summary>
        /// Sets the width of the tabs.
        /// </summary>
        [JsonProperty("tabWidthMode", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public TabWidthMode? TabWidthMode { get; set; }

        /// <summary>
        /// Determines the delimiters used in a double click selection.
        /// </summary>
        [JsonProperty("wordDelimiters", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public string WordDelimiters { get; set; }
    }

    public partial class Keybinding
    {
        /// <summary>
        /// The action executed when the associated key bindings are pressed.
        /// </summary>
        [JsonProperty("command", Required = Required.Always)]
        public Command Command { get; set; }

        /// <summary>
        /// Defines the key combinations used to call the command.
        /// </summary>
        [JsonProperty("keys", Required = Required.Always)]
        public Keys Keys { get; set; }
    }

    /// <summary>
    /// Arguments corresponding to a Copy Text Action
    ///
    /// Arguments corresponding to a New Tab Action
    ///
    /// Arguments corresponding to a Switch To Tab Action
    ///
    /// Arguments corresponding to a Move Focus Action
    ///
    /// Arguments corresponding to a Resize Pane Action
    ///
    /// Arguments corresponding to a Split Pane Action
    /// </summary>
    public partial class Action
    {
        /// <summary>
        /// The action to execute
        /// </summary>
        [JsonProperty("action", Required = Required.Always)]
        public ActionEnum ActionAction { get; set; }

        /// <summary>
        /// If true, whitespace is removed and newlines are maintained. If false, newlines are
        /// removed and whitespace is maintained.
        /// </summary>
        [JsonProperty("trimWhitespace", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public bool? TrimWhitespace { get; set; }

        /// <summary>
        /// A commandline to use instead of the profile's
        /// </summary>
        [JsonProperty("commandline", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public string Commandline { get; set; }

        /// <summary>
        /// The index of the profile in the new tab dropdown to open
        ///
        /// Which tab to switch to, with the first being 0
        /// </summary>
        [JsonProperty("index", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public long? Index { get; set; }

        /// <summary>
        /// Either the GUID or name of a profile to use, instead of launching the default
        /// </summary>
        [JsonProperty("profile", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public string Profile { get; set; }

        /// <summary>
        /// A startingDirectory to use instead of the profile's
        /// </summary>
        [JsonProperty("startingDirectory", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public string StartingDirectory { get; set; }

        /// <summary>
        /// An initial tabTitle to use instead of the profile's
        /// </summary>
        [JsonProperty("tabTitle", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public string TabTitle { get; set; }

        /// <summary>
        /// The direction to move focus in, between panes
        ///
        /// The direction to move the pane separator in
        /// </summary>
        [JsonProperty("direction", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public Direction? Direction { get; set; }

        /// <summary>
        /// The orientation to split the pane in, either vertical (think [|]), horizontal (think
        /// [-]), or auto (splits pane based on remaining space)
        /// </summary>
        [JsonProperty("split", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public SplitState? Split { get; set; }
    }

    /// <summary>
    /// A list of profiles and default settings that apply to all of them
    /// </summary>
    public partial class ProfilesObject
    {
        /// <summary>
        /// The default settings that apply to every profile.
        /// </summary>
        [JsonProperty("defaults", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public Profile Defaults { get; set; }

        [JsonProperty("list", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public List<ProfileList> List { get; set; }
    }

    /// <summary>
    /// The default settings that apply to every profile.
    ///
    /// Properties specific to a unique profile.
    /// </summary>
    public partial class Profile
    {
        /// <summary>
        /// When useAcrylic is set to true, it sets the transparency of the window for the profile.
        /// Accepts floating point values from 0-1 (default 0.5).
        /// </summary>
        [JsonProperty("acrylicOpacity", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        [JsonConverter(typeof(MinMaxValueCheckConverter))]
        public double? AcrylicOpacity { get; set; }

        /// <summary>
        /// Controls how text is antialiased in the renderer. Possible values are "grayscale",
        /// "cleartype" and "aliased". Note that changing this setting will require starting a new
        /// terminal instance.
        /// </summary>
        [JsonProperty("antialiasingMode", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public AntialiasingMode? AntialiasingMode { get; set; }

        /// <summary>
        /// Sets the background color of the profile. Overrides background set in color scheme if
        /// colorscheme is set. Uses hex color format: "#rrggbb".
        /// </summary>
        [JsonProperty("background", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public string Background { get; set; }

        /// <summary>
        /// Sets the file location of the Image to draw over the window background.
        /// </summary>
        [JsonProperty("backgroundImage", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public string BackgroundImage { get; set; }

        [JsonProperty("backgroundImageAlignment", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public BackgroundImageAlignment? BackgroundImageAlignment { get; set; }

        /// <summary>
        /// (Not in SettingsSchema.md)
        /// </summary>
        [JsonProperty("backgroundImageOpacity", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        [JsonConverter(typeof(MinMaxValueCheckConverter))]
        public double? BackgroundImageOpacity { get; set; }

        /// <summary>
        /// Sets how the background image is resized to fill the window.
        /// </summary>
        [JsonProperty("backgroundImageStretchMode", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public BackgroundImageStretchMode? BackgroundImageStretchMode { get; set; }

        /// <summary>
        /// Sets how the profile reacts to termination or failure to launch. Possible values:
        /// "graceful" (close when exit is typed or the process exits normally), "always" (always
        /// close) and "never" (never close). true and false are accepted as synonyms for "graceful"
        /// and "never" respectively.
        /// </summary>
        [JsonProperty("closeOnExit", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public CloseOnExitUnion? CloseOnExit { get; set; }

        /// <summary>
        /// Name of the terminal color scheme to use. Color schemes are defined under "schemes".
        /// </summary>
        [JsonProperty("colorScheme", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public string ColorScheme { get; set; }

        /// <summary>
        /// Array of colors used in the profile if colorscheme is not set. Colors use hex color
        /// format: "#rrggbb". Ordering is as follows: [black, red, green, yellow, blue, magenta,
        /// cyan, white, bright black, bright red, bright green, bright yellow, bright blue, bright
        /// magenta, bright cyan, bright white]
        /// </summary>
        [JsonProperty("colorTable", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public List<ColorTable> ColorTable { get; set; }

        /// <summary>
        /// Executable used in the profile.
        /// </summary>
        [JsonProperty("commandline", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public string Commandline { get; set; }

        /// <summary>
        /// A GUID reference to a connection type. Currently undocumented as of 0.3, this is used for
        /// Azure Cloud Shell
        /// </summary>
        [JsonProperty("connectionType", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public string ConnectionType { get; set; }

        /// <summary>
        /// Sets the cursor color for the profile. Uses hex color format: "#rrggbb".
        /// </summary>
        [JsonProperty("cursorColor", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public string CursorColor { get; set; }

        /// <summary>
        /// Sets the percentage height of the cursor starting from the bottom. Only works when
        /// cursorShape is set to "vintage". Accepts values from 25-100.
        /// </summary>
        [JsonProperty("cursorHeight", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public long? CursorHeight { get; set; }

        /// <summary>
        /// Sets the cursor shape for the profile. Possible values: "vintage" ( ▃ ), "bar" ( ┃,
        /// default ), "underscore" ( ▁ ), "filledBox" ( █ ), "emptyBox" ( ▯ )
        /// </summary>
        [JsonProperty("cursorShape", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public CursorShape? CursorShape { get; set; }

        /// <summary>
        /// When set to true, enable retro terminal effects. This is an experimental feature, and its
        /// continued existence is not guaranteed.
        /// </summary>
        [JsonProperty("experimental.retroTerminalEffect", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public bool? ExperimentalRetroTerminalEffect { get; set; }

        /// <summary>
        /// Name of the font face used in the profile.
        /// </summary>
        [JsonProperty("fontFace", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public string FontFace { get; set; }

        /// <summary>
        /// Sets the font size.
        /// </summary>
        [JsonProperty("fontSize", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public long? FontSize { get; set; }

        /// <summary>
        /// Sets the foreground color of the profile. Overrides foreground set in color scheme if
        /// colorscheme is set. Uses hex color format: "#rrggbb".
        /// </summary>
        [JsonProperty("foreground", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public string Foreground { get; set; }

        /// <summary>
        /// Unique identifier of the profile. Written in registry format:
        /// "{00000000-0000-0000-0000-000000000000}".
        /// </summary>
        [JsonProperty("guid", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public string Guid { get; set; }

        /// <summary>
        /// If set to true, the profile will not appear in the list of profiles. This can be used to
        /// hide default profiles and dynamically generated profiles, while leaving them in your
        /// settings file.
        /// </summary>
        [JsonProperty("hidden", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public bool? Hidden { get; set; }

        /// <summary>
        /// The number of lines above the ones displayed in the window you can scroll back to.
        /// </summary>
        [JsonProperty("historySize", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public long? HistorySize { get; set; }

        /// <summary>
        /// Image file location of the icon used in the profile. Displays within the tab and the
        /// dropdown menu.
        /// </summary>
        [JsonProperty("icon", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public string Icon { get; set; }

        /// <summary>
        /// Name of the profile. Displays in the dropdown menu.
        /// </summary>
        [JsonProperty("name", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        [JsonConverter(typeof(MinMaxLengthCheckConverter))]
        public string Name { get; set; }

        /// <summary>
        /// Sets the padding around the text within the window. Can have three different formats: "#"
        /// sets the same padding for all sides, "#, #" sets the same padding for left-right and
        /// top-bottom, and "#, #, #, #" sets the padding individually for left, top, right, and
        /// bottom.
        /// </summary>
        [JsonProperty("padding", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public string Padding { get; set; }

        /// <summary>
        /// Defines the visibility of the scrollbar.
        /// </summary>
        [JsonProperty("scrollbarState", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public ScrollbarState? ScrollbarState { get; set; }

        /// <summary>
        /// Sets the selection background color of the profile. Overrides selection background set in
        /// color scheme if colorscheme is set. Uses hex color format: "#rrggbb".
        /// </summary>
        [JsonProperty("selectionBackground", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public string SelectionBackground { get; set; }

        /// <summary>
        /// When set to true, the window will scroll to the command input line when typing. When set
        /// to false, the window will not scroll when you start typing.
        /// </summary>
        [JsonProperty("snapOnInput", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public bool? SnapOnInput { get; set; }

        /// <summary>
        /// Stores the name of the profile generator that originated this profile.
        /// </summary>
        [JsonProperty("source", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public string Source { get; set; }

        /// <summary>
        /// The directory the shell starts in when it is loaded.
        /// </summary>
        [JsonProperty("startingDirectory", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public string StartingDirectory { get; set; }

        /// <summary>
        /// When set to true, tabTitle overrides the default title of the tab and any title change
        /// messages from the application will be suppressed. When set to false, tabTitle behaves as
        /// normal.
        /// </summary>
        [JsonProperty("suppressApplicationTitle", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public bool? SuppressApplicationTitle { get; set; }

        /// <summary>
        /// If set, will replace the name as the title to pass to the shell on startup. Some shells
        /// (like bash) may choose to ignore this initial value, while others (cmd, powershell) may
        /// use this value over the lifetime of the application.
        /// </summary>
        [JsonProperty("tabTitle", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public string TabTitle { get; set; }

        /// <summary>
        /// When set to true, the window will have an acrylic background. When set to false, the
        /// window will have a plain, untextured background.
        /// </summary>
        [JsonProperty("useAcrylic", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public bool? UseAcrylic { get; set; }
    }

    public partial class ColorTable
    {
        /// <summary>
        /// Sets the background color of the color table.
        /// </summary>
        [JsonProperty("background", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public string Background { get; set; }

        /// <summary>
        /// Sets the color used as ANSI black.
        /// </summary>
        [JsonProperty("black", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public string Black { get; set; }

        /// <summary>
        /// Sets the color used as ANSI blue.
        /// </summary>
        [JsonProperty("blue", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public string Blue { get; set; }

        /// <summary>
        /// Sets the color used as ANSI bright black.
        /// </summary>
        [JsonProperty("brightBlack", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public string BrightBlack { get; set; }

        /// <summary>
        /// Sets the color used as ANSI bright blue.
        /// </summary>
        [JsonProperty("brightBlue", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public string BrightBlue { get; set; }

        /// <summary>
        /// Sets the color used as ANSI bright cyan.
        /// </summary>
        [JsonProperty("brightCyan", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public string BrightCyan { get; set; }

        /// <summary>
        /// Sets the color used as ANSI bright green.
        /// </summary>
        [JsonProperty("brightGreen", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public string BrightGreen { get; set; }

        /// <summary>
        /// Sets the color used as ANSI bright purple.
        /// </summary>
        [JsonProperty("brightPurple", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public string BrightPurple { get; set; }

        /// <summary>
        /// Sets the color used as ANSI bright red.
        /// </summary>
        [JsonProperty("brightRed", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public string BrightRed { get; set; }

        /// <summary>
        /// Sets the color used as ANSI bright white.
        /// </summary>
        [JsonProperty("brightWhite", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public string BrightWhite { get; set; }

        /// <summary>
        /// Sets the color used as ANSI bright yellow.
        /// </summary>
        [JsonProperty("brightYellow", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public string BrightYellow { get; set; }

        /// <summary>
        /// Sets the color used as ANSI cyan.
        /// </summary>
        [JsonProperty("cyan", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public string Cyan { get; set; }

        /// <summary>
        /// Sets the foreground color of the color table.
        /// </summary>
        [JsonProperty("foreground", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public string Foreground { get; set; }

        /// <summary>
        /// Sets the color used as ANSI green.
        /// </summary>
        [JsonProperty("green", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public string Green { get; set; }

        /// <summary>
        /// Sets the color used as ANSI purple.
        /// </summary>
        [JsonProperty("purple", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public string Purple { get; set; }

        /// <summary>
        /// Sets the color used as ANSI red.
        /// </summary>
        [JsonProperty("red", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public string Red { get; set; }

        /// <summary>
        /// Sets the color used as ANSI white.
        /// </summary>
        [JsonProperty("white", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public string White { get; set; }

        /// <summary>
        /// Sets the color used as ANSI yellow.
        /// </summary>
        [JsonProperty("yellow", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public string Yellow { get; set; }
    }

    /// <summary>
    /// A list of profiles and the properties specific to each.
    ///
    /// The default settings that apply to every profile.
    ///
    /// Properties specific to a unique profile.
    /// </summary>
    public partial class ProfileList
    {
        /// <summary>
        /// Unique identifier of the profile. Written in registry format:
        /// "{00000000-0000-0000-0000-000000000000}".
        /// </summary>
        [JsonProperty("guid", Required = Required.Always)]
        public string Guid { get; set; }

        /// <summary>
        /// Name of the profile. Displays in the dropdown menu.
        /// </summary>
        [JsonProperty("name", Required = Required.Always)]
        [JsonConverter(typeof(MinMaxLengthCheckConverter))]
        public string Name { get; set; }

        /// <summary>
        /// When useAcrylic is set to true, it sets the transparency of the window for the profile.
        /// Accepts floating point values from 0-1 (default 0.5).
        /// </summary>
        [JsonProperty("acrylicOpacity", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        [JsonConverter(typeof(MinMaxValueCheckConverter))]
        public double? AcrylicOpacity { get; set; }

        /// <summary>
        /// Controls how text is antialiased in the renderer. Possible values are "grayscale",
        /// "cleartype" and "aliased". Note that changing this setting will require starting a new
        /// terminal instance.
        /// </summary>
        [JsonProperty("antialiasingMode", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public AntialiasingMode? AntialiasingMode { get; set; }

        /// <summary>
        /// Sets the background color of the profile. Overrides background set in color scheme if
        /// colorscheme is set. Uses hex color format: "#rrggbb".
        /// </summary>
        [JsonProperty("background", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public string Background { get; set; }

        /// <summary>
        /// Sets the file location of the Image to draw over the window background.
        /// </summary>
        [JsonProperty("backgroundImage", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public string BackgroundImage { get; set; }

        [JsonProperty("backgroundImageAlignment", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public BackgroundImageAlignment? BackgroundImageAlignment { get; set; }

        /// <summary>
        /// (Not in SettingsSchema.md)
        /// </summary>
        [JsonProperty("backgroundImageOpacity", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        [JsonConverter(typeof(MinMaxValueCheckConverter))]
        public double? BackgroundImageOpacity { get; set; }

        /// <summary>
        /// Sets how the background image is resized to fill the window.
        /// </summary>
        [JsonProperty("backgroundImageStretchMode", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public BackgroundImageStretchMode? BackgroundImageStretchMode { get; set; }

        /// <summary>
        /// Sets how the profile reacts to termination or failure to launch. Possible values:
        /// "graceful" (close when exit is typed or the process exits normally), "always" (always
        /// close) and "never" (never close). true and false are accepted as synonyms for "graceful"
        /// and "never" respectively.
        /// </summary>
        [JsonProperty("closeOnExit", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public CloseOnExitUnion? CloseOnExit { get; set; }

        /// <summary>
        /// Name of the terminal color scheme to use. Color schemes are defined under "schemes".
        /// </summary>
        [JsonProperty("colorScheme", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public string ColorScheme { get; set; }

        /// <summary>
        /// Array of colors used in the profile if colorscheme is not set. Colors use hex color
        /// format: "#rrggbb". Ordering is as follows: [black, red, green, yellow, blue, magenta,
        /// cyan, white, bright black, bright red, bright green, bright yellow, bright blue, bright
        /// magenta, bright cyan, bright white]
        /// </summary>
        [JsonProperty("colorTable", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public List<ColorTable> ColorTable { get; set; }

        /// <summary>
        /// Executable used in the profile.
        /// </summary>
        [JsonProperty("commandline", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public string Commandline { get; set; }

        /// <summary>
        /// A GUID reference to a connection type. Currently undocumented as of 0.3, this is used for
        /// Azure Cloud Shell
        /// </summary>
        [JsonProperty("connectionType", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public string ConnectionType { get; set; }

        /// <summary>
        /// Sets the cursor color for the profile. Uses hex color format: "#rrggbb".
        /// </summary>
        [JsonProperty("cursorColor", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public string CursorColor { get; set; }

        /// <summary>
        /// Sets the percentage height of the cursor starting from the bottom. Only works when
        /// cursorShape is set to "vintage". Accepts values from 25-100.
        /// </summary>
        [JsonProperty("cursorHeight", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public long? CursorHeight { get; set; }

        /// <summary>
        /// Sets the cursor shape for the profile. Possible values: "vintage" ( ▃ ), "bar" ( ┃,
        /// default ), "underscore" ( ▁ ), "filledBox" ( █ ), "emptyBox" ( ▯ )
        /// </summary>
        [JsonProperty("cursorShape", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public CursorShape? CursorShape { get; set; }

        /// <summary>
        /// When set to true, enable retro terminal effects. This is an experimental feature, and its
        /// continued existence is not guaranteed.
        /// </summary>
        [JsonProperty("experimental.retroTerminalEffect", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public bool? ExperimentalRetroTerminalEffect { get; set; }

        /// <summary>
        /// Name of the font face used in the profile.
        /// </summary>
        [JsonProperty("fontFace", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public string FontFace { get; set; }

        /// <summary>
        /// Sets the font size.
        /// </summary>
        [JsonProperty("fontSize", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public long? FontSize { get; set; }

        /// <summary>
        /// Sets the foreground color of the profile. Overrides foreground set in color scheme if
        /// colorscheme is set. Uses hex color format: "#rrggbb".
        /// </summary>
        [JsonProperty("foreground", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public string Foreground { get; set; }

        /// <summary>
        /// If set to true, the profile will not appear in the list of profiles. This can be used to
        /// hide default profiles and dynamically generated profiles, while leaving them in your
        /// settings file.
        /// </summary>
        [JsonProperty("hidden", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public bool? Hidden { get; set; }

        /// <summary>
        /// The number of lines above the ones displayed in the window you can scroll back to.
        /// </summary>
        [JsonProperty("historySize", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public long? HistorySize { get; set; }

        /// <summary>
        /// Image file location of the icon used in the profile. Displays within the tab and the
        /// dropdown menu.
        /// </summary>
        [JsonProperty("icon", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public string Icon { get; set; }

        /// <summary>
        /// Sets the padding around the text within the window. Can have three different formats: "#"
        /// sets the same padding for all sides, "#, #" sets the same padding for left-right and
        /// top-bottom, and "#, #, #, #" sets the padding individually for left, top, right, and
        /// bottom.
        /// </summary>
        [JsonProperty("padding", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public string Padding { get; set; }

        /// <summary>
        /// Defines the visibility of the scrollbar.
        /// </summary>
        [JsonProperty("scrollbarState", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public ScrollbarState? ScrollbarState { get; set; }

        /// <summary>
        /// Sets the selection background color of the profile. Overrides selection background set in
        /// color scheme if colorscheme is set. Uses hex color format: "#rrggbb".
        /// </summary>
        [JsonProperty("selectionBackground", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public string SelectionBackground { get; set; }

        /// <summary>
        /// When set to true, the window will scroll to the command input line when typing. When set
        /// to false, the window will not scroll when you start typing.
        /// </summary>
        [JsonProperty("snapOnInput", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public bool? SnapOnInput { get; set; }

        /// <summary>
        /// Stores the name of the profile generator that originated this profile.
        /// </summary>
        [JsonProperty("source", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public string Source { get; set; }

        /// <summary>
        /// The directory the shell starts in when it is loaded.
        /// </summary>
        [JsonProperty("startingDirectory", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public string StartingDirectory { get; set; }

        /// <summary>
        /// When set to true, tabTitle overrides the default title of the tab and any title change
        /// messages from the application will be suppressed. When set to false, tabTitle behaves as
        /// normal.
        /// </summary>
        [JsonProperty("suppressApplicationTitle", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public bool? SuppressApplicationTitle { get; set; }

        /// <summary>
        /// If set, will replace the name as the title to pass to the shell on startup. Some shells
        /// (like bash) may choose to ignore this initial value, while others (cmd, powershell) may
        /// use this value over the lifetime of the application.
        /// </summary>
        [JsonProperty("tabTitle", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public string TabTitle { get; set; }

        /// <summary>
        /// When set to true, the window will have an acrylic background. When set to false, the
        /// window will have a plain, untextured background.
        /// </summary>
        [JsonProperty("useAcrylic", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public bool? UseAcrylic { get; set; }
    }

    /// <summary>
    /// Properties are specific to each color scheme. ColorTool is a great tool you can use to
    /// create and explore new color schemes. All colors use hex color format.
    /// </summary>
    public partial class SchemeList
    {
        /// <summary>
        /// Sets the background color of the color scheme.
        /// </summary>
        [JsonProperty("background", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public string Background { get; set; }

        /// <summary>
        /// Sets the color used as ANSI black.
        /// </summary>
        [JsonProperty("black", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public string Black { get; set; }

        /// <summary>
        /// Sets the color used as ANSI blue.
        /// </summary>
        [JsonProperty("blue", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public string Blue { get; set; }

        /// <summary>
        /// Sets the color used as ANSI bright black.
        /// </summary>
        [JsonProperty("brightBlack", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public string BrightBlack { get; set; }

        /// <summary>
        /// Sets the color used as ANSI bright blue.
        /// </summary>
        [JsonProperty("brightBlue", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public string BrightBlue { get; set; }

        /// <summary>
        /// Sets the color used as ANSI bright cyan.
        /// </summary>
        [JsonProperty("brightCyan", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public string BrightCyan { get; set; }

        /// <summary>
        /// Sets the color used as ANSI bright green.
        /// </summary>
        [JsonProperty("brightGreen", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public string BrightGreen { get; set; }

        /// <summary>
        /// Sets the color used as ANSI bright purple.
        /// </summary>
        [JsonProperty("brightPurple", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public string BrightPurple { get; set; }

        /// <summary>
        /// Sets the color used as ANSI bright red.
        /// </summary>
        [JsonProperty("brightRed", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public string BrightRed { get; set; }

        /// <summary>
        /// Sets the color used as ANSI bright white.
        /// </summary>
        [JsonProperty("brightWhite", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public string BrightWhite { get; set; }

        /// <summary>
        /// Sets the color used as ANSI bright yellow.
        /// </summary>
        [JsonProperty("brightYellow", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public string BrightYellow { get; set; }

        /// <summary>
        /// Sets the color used as ANSI cyan.
        /// </summary>
        [JsonProperty("cyan", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public string Cyan { get; set; }

        /// <summary>
        /// Sets the foreground color of the color scheme.
        /// </summary>
        [JsonProperty("foreground", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public string Foreground { get; set; }

        /// <summary>
        /// Sets the color used as ANSI green.
        /// </summary>
        [JsonProperty("green", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public string Green { get; set; }

        /// <summary>
        /// Name of the color scheme.
        /// </summary>
        [JsonProperty("name", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        [JsonConverter(typeof(MinMaxLengthCheckConverter))]
        public string Name { get; set; }

        /// <summary>
        /// Sets the color used as ANSI purple.
        /// </summary>
        [JsonProperty("purple", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public string Purple { get; set; }

        /// <summary>
        /// Sets the color used as ANSI red.
        /// </summary>
        [JsonProperty("red", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public string Red { get; set; }

        /// <summary>
        /// Sets the selection background color of the color scheme.
        /// </summary>
        [JsonProperty("selectionBackground", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public string SelectionBackground { get; set; }

        /// <summary>
        /// Sets the color used as ANSI white.
        /// </summary>
        [JsonProperty("white", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public string White { get; set; }

        /// <summary>
        /// Sets the color used as ANSI yellow.
        /// </summary>
        [JsonProperty("yellow", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public string Yellow { get; set; }
    }

    /// <summary>
    /// The action to execute
    /// </summary>
    public enum CommandEnum { ClosePane, CloseTab, CloseWindow, Copy, CopyTextWithoutNewlines, DecreaseFontSize, DuplicateTab, Find, IncreaseFontSize, MoveFocus, MoveFocusDown, MoveFocusLeft, MoveFocusRight, MoveFocusUp, NewTab, NewTabProfile0, NewTabProfile1, NewTabProfile2, NewTabProfile3, NewTabProfile4, NewTabProfile5, NewTabProfile6, NewTabProfile7, NewTabProfile8, NextTab, OpenNewTabDropdown, OpenSettings, Paste, PrevTab, ResetFontSize, ResizePane, ResizePaneDown, ResizePaneLeft, ResizePaneRight, ResizePaneUp, ScrollDown, ScrollDownPage, ScrollUp, ScrollUpPage, SplitHorizontal, SplitPane, SplitVertical, SwitchToTab, SwitchToTab0, SwitchToTab1, SwitchToTab2, SwitchToTab3, SwitchToTab4, SwitchToTab5, SwitchToTab6, SwitchToTab7, SwitchToTab8, ToggleFullscreen };

    /// <summary>
    /// The action to execute
    /// </summary>
    public enum ActionEnum { ClosePane, CloseTab, CloseWindow, Copy, CopyTextWithoutNewlines, DecreaseFontSize, DuplicateTab, Find, IncreaseFontSize, MoveFocus, MoveFocusDown, MoveFocusLeft, MoveFocusRight, MoveFocusUp, NewTab, NewTabProfile0, NewTabProfile1, NewTabProfile2, NewTabProfile3, NewTabProfile4, NewTabProfile5, NewTabProfile6, NewTabProfile7, NewTabProfile8, NextTab, OpenNewTabDropdown, OpenSettings, Paste, PrevTab, ResetFontSize, ResizePane, ResizePaneDown, ResizePaneLeft, ResizePaneRight, ResizePaneUp, ScrollDown, ScrollDownPage, ScrollUp, ScrollUpPage, SplitHorizontal, SplitPane, SplitVertical, SwitchToTab, SwitchToTab0, SwitchToTab1, SwitchToTab2, SwitchToTab3, SwitchToTab4, SwitchToTab5, SwitchToTab6, SwitchToTab7, SwitchToTab8, ToggleFullscreen };

    /// <summary>
    /// The direction to move focus in, between panes
    ///
    /// The direction to move the pane separator in
    /// </summary>
    public enum Direction { Down, Left, Right, Up };

    /// <summary>
    /// The orientation to split the pane in, either vertical (think [|]), horizontal (think
    /// [-]), or auto (splits pane based on remaining space)
    /// </summary>
    public enum SplitState { Auto, Horizontal, Vertical };

    /// <summary>
    /// Defines whether the Terminal will launch as maximized or not.
    /// </summary>
    public enum LaunchMode { Default, Maximized };

    /// <summary>
    /// Controls how text is antialiased in the renderer. Possible values are "grayscale",
    /// "cleartype" and "aliased". Note that changing this setting will require starting a new
    /// terminal instance.
    /// </summary>
    public enum AntialiasingMode { Aliased, Cleartype, Grayscale };

    public enum BackgroundImageAlignment { Bottom, BottomLeft, BottomRight, Center, Left, Right, Top, TopLeft, TopRight };

    /// <summary>
    /// Sets how the background image is resized to fill the window.
    /// </summary>
    public enum BackgroundImageStretchMode { Fill, None, Uniform, UniformToFill };

    public enum CloseOnExitEnum { Always, Graceful, Never };

    /// <summary>
    /// Sets the cursor shape for the profile. Possible values: "vintage" ( ▃ ), "bar" ( ┃,
    /// default ), "underscore" ( ▁ ), "filledBox" ( █ ), "emptyBox" ( ▯ )
    /// </summary>
    public enum CursorShape { Bar, EmptyBox, FilledBox, Underscore, Vintage };

    /// <summary>
    /// Defines the visibility of the scrollbar.
    /// </summary>
    public enum ScrollbarState { Hidden, Visible };

    /// <summary>
    /// Sets the theme of the application.
    /// </summary>
    public enum RequestedTheme { Dark, Light, System };

    /// <summary>
    /// Sets the width of the tabs.
    /// </summary>
    public enum TabWidthMode { Equal, TitleLength };

    /// <summary>
    /// The action executed when the associated key bindings are pressed.
    /// </summary>
    public partial struct Command
    {
        public Action Action;
        public CommandEnum? Enum;

        public static implicit operator Command(Action Action) => new Command { Action = Action };
        public static implicit operator Command(CommandEnum Enum) => new Command { Enum = Enum };
    }

    /// <summary>
    /// Defines the key combinations used to call the command.
    /// </summary>
    public partial struct Keys
    {
        public string String;
        public List<string> StringArray;

        public static implicit operator Keys(string String) => new Keys { String = String };
        public static implicit operator Keys(List<string> StringArray) => new Keys { StringArray = StringArray };
    }

    /// <summary>
    /// Sets how the profile reacts to termination or failure to launch. Possible values:
    /// "graceful" (close when exit is typed or the process exits normally), "always" (always
    /// close) and "never" (never close). true and false are accepted as synonyms for "graceful"
    /// and "never" respectively.
    /// </summary>
    public partial struct CloseOnExitUnion
    {
        public bool? Bool;
        public CloseOnExitEnum? Enum;

        public static implicit operator CloseOnExitUnion(bool Bool) => new CloseOnExitUnion { Bool = Bool };
        public static implicit operator CloseOnExitUnion(CloseOnExitEnum Enum) => new CloseOnExitUnion { Enum = Enum };
    }

    /// <summary>
    /// The number of rows to scroll at a time with the mouse wheel. This will override the
    /// system setting if the value is not zero or 'system'.
    /// </summary>
    public partial struct RowsToScroll
    {
        public long? Integer;
        public string String;

        public static implicit operator RowsToScroll(long Integer) => new RowsToScroll { Integer = Integer };
        public static implicit operator RowsToScroll(string String) => new RowsToScroll { String = String };
    }

    public partial class TerminalSettings
    {
        public static TerminalSettings FromJson(string json) => JsonConvert.DeserializeObject<TerminalSettings>(json, WindowsTerminal.Converter.Settings);
    }

    public static class Serialize
    {
        public static string ToJson(this TerminalSettings self) => JsonConvert.SerializeObject(self, WindowsTerminal.Converter.Settings);
    }

    internal static class Converter
    {
        public static readonly JsonSerializerSettings Settings = new JsonSerializerSettings
        {
            MetadataPropertyHandling = MetadataPropertyHandling.Ignore,
            DateParseHandling = DateParseHandling.None,
            Formatting = Formatting.Indented,
            Converters =
            {
                CommandConverter.Singleton,
                ActionEnumConverter.Singleton,
                DirectionConverter.Singleton,
                SplitStateConverter.Singleton,
                CommandEnumConverter.Singleton,
                KeysConverter.Singleton,
                LaunchModeConverter.Singleton,
                AntialiasingModeConverter.Singleton,
                BackgroundImageAlignmentConverter.Singleton,
                BackgroundImageStretchModeConverter.Singleton,
                CloseOnExitUnionConverter.Singleton,
                CloseOnExitEnumConverter.Singleton,
                CursorShapeConverter.Singleton,
                ScrollbarStateConverter.Singleton,
                RequestedThemeConverter.Singleton,
                RowsToScrollConverter.Singleton,
                TabWidthModeConverter.Singleton,
                new IsoDateTimeConverter { DateTimeStyles = DateTimeStyles.AssumeUniversal }
            },
        };
    }

    internal class CommandConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(Command) || t == typeof(Command?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            switch (reader.TokenType)
            {
                case JsonToken.String:
                case JsonToken.Date:
                    var stringValue = serializer.Deserialize<string>(reader);
                    switch (stringValue)
                    {
                        case "closePane":
                            return new Command { Enum = CommandEnum.ClosePane };
                        case "closeTab":
                            return new Command { Enum = CommandEnum.CloseTab };
                        case "closeWindow":
                            return new Command { Enum = CommandEnum.CloseWindow };
                        case "copy":
                            return new Command { Enum = CommandEnum.Copy };
                        case "copyTextWithoutNewlines":
                            return new Command { Enum = CommandEnum.CopyTextWithoutNewlines };
                        case "decreaseFontSize":
                            return new Command { Enum = CommandEnum.DecreaseFontSize };
                        case "duplicateTab":
                            return new Command { Enum = CommandEnum.DuplicateTab };
                        case "find":
                            return new Command { Enum = CommandEnum.Find };
                        case "increaseFontSize":
                            return new Command { Enum = CommandEnum.IncreaseFontSize };
                        case "moveFocus":
                            return new Command { Enum = CommandEnum.MoveFocus };
                        case "moveFocusDown":
                            return new Command { Enum = CommandEnum.MoveFocusDown };
                        case "moveFocusLeft":
                            return new Command { Enum = CommandEnum.MoveFocusLeft };
                        case "moveFocusRight":
                            return new Command { Enum = CommandEnum.MoveFocusRight };
                        case "moveFocusUp":
                            return new Command { Enum = CommandEnum.MoveFocusUp };
                        case "newTab":
                            return new Command { Enum = CommandEnum.NewTab };
                        case "newTabProfile0":
                            return new Command { Enum = CommandEnum.NewTabProfile0 };
                        case "newTabProfile1":
                            return new Command { Enum = CommandEnum.NewTabProfile1 };
                        case "newTabProfile2":
                            return new Command { Enum = CommandEnum.NewTabProfile2 };
                        case "newTabProfile3":
                            return new Command { Enum = CommandEnum.NewTabProfile3 };
                        case "newTabProfile4":
                            return new Command { Enum = CommandEnum.NewTabProfile4 };
                        case "newTabProfile5":
                            return new Command { Enum = CommandEnum.NewTabProfile5 };
                        case "newTabProfile6":
                            return new Command { Enum = CommandEnum.NewTabProfile6 };
                        case "newTabProfile7":
                            return new Command { Enum = CommandEnum.NewTabProfile7 };
                        case "newTabProfile8":
                            return new Command { Enum = CommandEnum.NewTabProfile8 };
                        case "nextTab":
                            return new Command { Enum = CommandEnum.NextTab };
                        case "openNewTabDropdown":
                            return new Command { Enum = CommandEnum.OpenNewTabDropdown };
                        case "openSettings":
                            return new Command { Enum = CommandEnum.OpenSettings };
                        case "paste":
                            return new Command { Enum = CommandEnum.Paste };
                        case "prevTab":
                            return new Command { Enum = CommandEnum.PrevTab };
                        case "resetFontSize":
                            return new Command { Enum = CommandEnum.ResetFontSize };
                        case "resizePane":
                            return new Command { Enum = CommandEnum.ResizePane };
                        case "resizePaneDown":
                            return new Command { Enum = CommandEnum.ResizePaneDown };
                        case "resizePaneLeft":
                            return new Command { Enum = CommandEnum.ResizePaneLeft };
                        case "resizePaneRight":
                            return new Command { Enum = CommandEnum.ResizePaneRight };
                        case "resizePaneUp":
                            return new Command { Enum = CommandEnum.ResizePaneUp };
                        case "scrollDown":
                            return new Command { Enum = CommandEnum.ScrollDown };
                        case "scrollDownPage":
                            return new Command { Enum = CommandEnum.ScrollDownPage };
                        case "scrollUp":
                            return new Command { Enum = CommandEnum.ScrollUp };
                        case "scrollUpPage":
                            return new Command { Enum = CommandEnum.ScrollUpPage };
                        case "splitHorizontal":
                            return new Command { Enum = CommandEnum.SplitHorizontal };
                        case "splitPane":
                            return new Command { Enum = CommandEnum.SplitPane };
                        case "splitVertical":
                            return new Command { Enum = CommandEnum.SplitVertical };
                        case "switchToTab":
                            return new Command { Enum = CommandEnum.SwitchToTab };
                        case "switchToTab0":
                            return new Command { Enum = CommandEnum.SwitchToTab0 };
                        case "switchToTab1":
                            return new Command { Enum = CommandEnum.SwitchToTab1 };
                        case "switchToTab2":
                            return new Command { Enum = CommandEnum.SwitchToTab2 };
                        case "switchToTab3":
                            return new Command { Enum = CommandEnum.SwitchToTab3 };
                        case "switchToTab4":
                            return new Command { Enum = CommandEnum.SwitchToTab4 };
                        case "switchToTab5":
                            return new Command { Enum = CommandEnum.SwitchToTab5 };
                        case "switchToTab6":
                            return new Command { Enum = CommandEnum.SwitchToTab6 };
                        case "switchToTab7":
                            return new Command { Enum = CommandEnum.SwitchToTab7 };
                        case "switchToTab8":
                            return new Command { Enum = CommandEnum.SwitchToTab8 };
                        case "toggleFullscreen":
                            return new Command { Enum = CommandEnum.ToggleFullscreen };
                    }
                    break;
                case JsonToken.StartObject:
                    var objectValue = serializer.Deserialize<Action>(reader);
                    return new Command { Action = objectValue };
            }
            throw new Exception("Cannot unmarshal type Command");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            var value = (Command)untypedValue;
            if (value.Enum != null)
            {
                switch (value.Enum)
                {
                    case CommandEnum.ClosePane:
                        serializer.Serialize(writer, "closePane");
                        return;
                    case CommandEnum.CloseTab:
                        serializer.Serialize(writer, "closeTab");
                        return;
                    case CommandEnum.CloseWindow:
                        serializer.Serialize(writer, "closeWindow");
                        return;
                    case CommandEnum.Copy:
                        serializer.Serialize(writer, "copy");
                        return;
                    case CommandEnum.CopyTextWithoutNewlines:
                        serializer.Serialize(writer, "copyTextWithoutNewlines");
                        return;
                    case CommandEnum.DecreaseFontSize:
                        serializer.Serialize(writer, "decreaseFontSize");
                        return;
                    case CommandEnum.DuplicateTab:
                        serializer.Serialize(writer, "duplicateTab");
                        return;
                    case CommandEnum.Find:
                        serializer.Serialize(writer, "find");
                        return;
                    case CommandEnum.IncreaseFontSize:
                        serializer.Serialize(writer, "increaseFontSize");
                        return;
                    case CommandEnum.MoveFocus:
                        serializer.Serialize(writer, "moveFocus");
                        return;
                    case CommandEnum.MoveFocusDown:
                        serializer.Serialize(writer, "moveFocusDown");
                        return;
                    case CommandEnum.MoveFocusLeft:
                        serializer.Serialize(writer, "moveFocusLeft");
                        return;
                    case CommandEnum.MoveFocusRight:
                        serializer.Serialize(writer, "moveFocusRight");
                        return;
                    case CommandEnum.MoveFocusUp:
                        serializer.Serialize(writer, "moveFocusUp");
                        return;
                    case CommandEnum.NewTab:
                        serializer.Serialize(writer, "newTab");
                        return;
                    case CommandEnum.NewTabProfile0:
                        serializer.Serialize(writer, "newTabProfile0");
                        return;
                    case CommandEnum.NewTabProfile1:
                        serializer.Serialize(writer, "newTabProfile1");
                        return;
                    case CommandEnum.NewTabProfile2:
                        serializer.Serialize(writer, "newTabProfile2");
                        return;
                    case CommandEnum.NewTabProfile3:
                        serializer.Serialize(writer, "newTabProfile3");
                        return;
                    case CommandEnum.NewTabProfile4:
                        serializer.Serialize(writer, "newTabProfile4");
                        return;
                    case CommandEnum.NewTabProfile5:
                        serializer.Serialize(writer, "newTabProfile5");
                        return;
                    case CommandEnum.NewTabProfile6:
                        serializer.Serialize(writer, "newTabProfile6");
                        return;
                    case CommandEnum.NewTabProfile7:
                        serializer.Serialize(writer, "newTabProfile7");
                        return;
                    case CommandEnum.NewTabProfile8:
                        serializer.Serialize(writer, "newTabProfile8");
                        return;
                    case CommandEnum.NextTab:
                        serializer.Serialize(writer, "nextTab");
                        return;
                    case CommandEnum.OpenNewTabDropdown:
                        serializer.Serialize(writer, "openNewTabDropdown");
                        return;
                    case CommandEnum.OpenSettings:
                        serializer.Serialize(writer, "openSettings");
                        return;
                    case CommandEnum.Paste:
                        serializer.Serialize(writer, "paste");
                        return;
                    case CommandEnum.PrevTab:
                        serializer.Serialize(writer, "prevTab");
                        return;
                    case CommandEnum.ResetFontSize:
                        serializer.Serialize(writer, "resetFontSize");
                        return;
                    case CommandEnum.ResizePane:
                        serializer.Serialize(writer, "resizePane");
                        return;
                    case CommandEnum.ResizePaneDown:
                        serializer.Serialize(writer, "resizePaneDown");
                        return;
                    case CommandEnum.ResizePaneLeft:
                        serializer.Serialize(writer, "resizePaneLeft");
                        return;
                    case CommandEnum.ResizePaneRight:
                        serializer.Serialize(writer, "resizePaneRight");
                        return;
                    case CommandEnum.ResizePaneUp:
                        serializer.Serialize(writer, "resizePaneUp");
                        return;
                    case CommandEnum.ScrollDown:
                        serializer.Serialize(writer, "scrollDown");
                        return;
                    case CommandEnum.ScrollDownPage:
                        serializer.Serialize(writer, "scrollDownPage");
                        return;
                    case CommandEnum.ScrollUp:
                        serializer.Serialize(writer, "scrollUp");
                        return;
                    case CommandEnum.ScrollUpPage:
                        serializer.Serialize(writer, "scrollUpPage");
                        return;
                    case CommandEnum.SplitHorizontal:
                        serializer.Serialize(writer, "splitHorizontal");
                        return;
                    case CommandEnum.SplitPane:
                        serializer.Serialize(writer, "splitPane");
                        return;
                    case CommandEnum.SplitVertical:
                        serializer.Serialize(writer, "splitVertical");
                        return;
                    case CommandEnum.SwitchToTab:
                        serializer.Serialize(writer, "switchToTab");
                        return;
                    case CommandEnum.SwitchToTab0:
                        serializer.Serialize(writer, "switchToTab0");
                        return;
                    case CommandEnum.SwitchToTab1:
                        serializer.Serialize(writer, "switchToTab1");
                        return;
                    case CommandEnum.SwitchToTab2:
                        serializer.Serialize(writer, "switchToTab2");
                        return;
                    case CommandEnum.SwitchToTab3:
                        serializer.Serialize(writer, "switchToTab3");
                        return;
                    case CommandEnum.SwitchToTab4:
                        serializer.Serialize(writer, "switchToTab4");
                        return;
                    case CommandEnum.SwitchToTab5:
                        serializer.Serialize(writer, "switchToTab5");
                        return;
                    case CommandEnum.SwitchToTab6:
                        serializer.Serialize(writer, "switchToTab6");
                        return;
                    case CommandEnum.SwitchToTab7:
                        serializer.Serialize(writer, "switchToTab7");
                        return;
                    case CommandEnum.SwitchToTab8:
                        serializer.Serialize(writer, "switchToTab8");
                        return;
                    case CommandEnum.ToggleFullscreen:
                        serializer.Serialize(writer, "toggleFullscreen");
                        return;
                }
            }
            if (value.Action != null)
            {
                serializer.Serialize(writer, value.Action);
                return;
            }
            throw new Exception("Cannot marshal type Command");
        }

        public static readonly CommandConverter Singleton = new CommandConverter();
    }

    internal class ActionEnumConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(ActionEnum) || t == typeof(ActionEnum?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "closePane":
                    return ActionEnum.ClosePane;
                case "closeTab":
                    return ActionEnum.CloseTab;
                case "closeWindow":
                    return ActionEnum.CloseWindow;
                case "copy":
                    return ActionEnum.Copy;
                case "copyTextWithoutNewlines":
                    return ActionEnum.CopyTextWithoutNewlines;
                case "decreaseFontSize":
                    return ActionEnum.DecreaseFontSize;
                case "duplicateTab":
                    return ActionEnum.DuplicateTab;
                case "find":
                    return ActionEnum.Find;
                case "increaseFontSize":
                    return ActionEnum.IncreaseFontSize;
                case "moveFocus":
                    return ActionEnum.MoveFocus;
                case "moveFocusDown":
                    return ActionEnum.MoveFocusDown;
                case "moveFocusLeft":
                    return ActionEnum.MoveFocusLeft;
                case "moveFocusRight":
                    return ActionEnum.MoveFocusRight;
                case "moveFocusUp":
                    return ActionEnum.MoveFocusUp;
                case "newTab":
                    return ActionEnum.NewTab;
                case "newTabProfile0":
                    return ActionEnum.NewTabProfile0;
                case "newTabProfile1":
                    return ActionEnum.NewTabProfile1;
                case "newTabProfile2":
                    return ActionEnum.NewTabProfile2;
                case "newTabProfile3":
                    return ActionEnum.NewTabProfile3;
                case "newTabProfile4":
                    return ActionEnum.NewTabProfile4;
                case "newTabProfile5":
                    return ActionEnum.NewTabProfile5;
                case "newTabProfile6":
                    return ActionEnum.NewTabProfile6;
                case "newTabProfile7":
                    return ActionEnum.NewTabProfile7;
                case "newTabProfile8":
                    return ActionEnum.NewTabProfile8;
                case "nextTab":
                    return ActionEnum.NextTab;
                case "openNewTabDropdown":
                    return ActionEnum.OpenNewTabDropdown;
                case "openSettings":
                    return ActionEnum.OpenSettings;
                case "paste":
                    return ActionEnum.Paste;
                case "prevTab":
                    return ActionEnum.PrevTab;
                case "resetFontSize":
                    return ActionEnum.ResetFontSize;
                case "resizePane":
                    return ActionEnum.ResizePane;
                case "resizePaneDown":
                    return ActionEnum.ResizePaneDown;
                case "resizePaneLeft":
                    return ActionEnum.ResizePaneLeft;
                case "resizePaneRight":
                    return ActionEnum.ResizePaneRight;
                case "resizePaneUp":
                    return ActionEnum.ResizePaneUp;
                case "scrollDown":
                    return ActionEnum.ScrollDown;
                case "scrollDownPage":
                    return ActionEnum.ScrollDownPage;
                case "scrollUp":
                    return ActionEnum.ScrollUp;
                case "scrollUpPage":
                    return ActionEnum.ScrollUpPage;
                case "splitHorizontal":
                    return ActionEnum.SplitHorizontal;
                case "splitPane":
                    return ActionEnum.SplitPane;
                case "splitVertical":
                    return ActionEnum.SplitVertical;
                case "switchToTab":
                    return ActionEnum.SwitchToTab;
                case "switchToTab0":
                    return ActionEnum.SwitchToTab0;
                case "switchToTab1":
                    return ActionEnum.SwitchToTab1;
                case "switchToTab2":
                    return ActionEnum.SwitchToTab2;
                case "switchToTab3":
                    return ActionEnum.SwitchToTab3;
                case "switchToTab4":
                    return ActionEnum.SwitchToTab4;
                case "switchToTab5":
                    return ActionEnum.SwitchToTab5;
                case "switchToTab6":
                    return ActionEnum.SwitchToTab6;
                case "switchToTab7":
                    return ActionEnum.SwitchToTab7;
                case "switchToTab8":
                    return ActionEnum.SwitchToTab8;
                case "toggleFullscreen":
                    return ActionEnum.ToggleFullscreen;
            }
            throw new Exception("Cannot unmarshal type ActionEnum");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (ActionEnum)untypedValue;
            switch (value)
            {
                case ActionEnum.ClosePane:
                    serializer.Serialize(writer, "closePane");
                    return;
                case ActionEnum.CloseTab:
                    serializer.Serialize(writer, "closeTab");
                    return;
                case ActionEnum.CloseWindow:
                    serializer.Serialize(writer, "closeWindow");
                    return;
                case ActionEnum.Copy:
                    serializer.Serialize(writer, "copy");
                    return;
                case ActionEnum.CopyTextWithoutNewlines:
                    serializer.Serialize(writer, "copyTextWithoutNewlines");
                    return;
                case ActionEnum.DecreaseFontSize:
                    serializer.Serialize(writer, "decreaseFontSize");
                    return;
                case ActionEnum.DuplicateTab:
                    serializer.Serialize(writer, "duplicateTab");
                    return;
                case ActionEnum.Find:
                    serializer.Serialize(writer, "find");
                    return;
                case ActionEnum.IncreaseFontSize:
                    serializer.Serialize(writer, "increaseFontSize");
                    return;
                case ActionEnum.MoveFocus:
                    serializer.Serialize(writer, "moveFocus");
                    return;
                case ActionEnum.MoveFocusDown:
                    serializer.Serialize(writer, "moveFocusDown");
                    return;
                case ActionEnum.MoveFocusLeft:
                    serializer.Serialize(writer, "moveFocusLeft");
                    return;
                case ActionEnum.MoveFocusRight:
                    serializer.Serialize(writer, "moveFocusRight");
                    return;
                case ActionEnum.MoveFocusUp:
                    serializer.Serialize(writer, "moveFocusUp");
                    return;
                case ActionEnum.NewTab:
                    serializer.Serialize(writer, "newTab");
                    return;
                case ActionEnum.NewTabProfile0:
                    serializer.Serialize(writer, "newTabProfile0");
                    return;
                case ActionEnum.NewTabProfile1:
                    serializer.Serialize(writer, "newTabProfile1");
                    return;
                case ActionEnum.NewTabProfile2:
                    serializer.Serialize(writer, "newTabProfile2");
                    return;
                case ActionEnum.NewTabProfile3:
                    serializer.Serialize(writer, "newTabProfile3");
                    return;
                case ActionEnum.NewTabProfile4:
                    serializer.Serialize(writer, "newTabProfile4");
                    return;
                case ActionEnum.NewTabProfile5:
                    serializer.Serialize(writer, "newTabProfile5");
                    return;
                case ActionEnum.NewTabProfile6:
                    serializer.Serialize(writer, "newTabProfile6");
                    return;
                case ActionEnum.NewTabProfile7:
                    serializer.Serialize(writer, "newTabProfile7");
                    return;
                case ActionEnum.NewTabProfile8:
                    serializer.Serialize(writer, "newTabProfile8");
                    return;
                case ActionEnum.NextTab:
                    serializer.Serialize(writer, "nextTab");
                    return;
                case ActionEnum.OpenNewTabDropdown:
                    serializer.Serialize(writer, "openNewTabDropdown");
                    return;
                case ActionEnum.OpenSettings:
                    serializer.Serialize(writer, "openSettings");
                    return;
                case ActionEnum.Paste:
                    serializer.Serialize(writer, "paste");
                    return;
                case ActionEnum.PrevTab:
                    serializer.Serialize(writer, "prevTab");
                    return;
                case ActionEnum.ResetFontSize:
                    serializer.Serialize(writer, "resetFontSize");
                    return;
                case ActionEnum.ResizePane:
                    serializer.Serialize(writer, "resizePane");
                    return;
                case ActionEnum.ResizePaneDown:
                    serializer.Serialize(writer, "resizePaneDown");
                    return;
                case ActionEnum.ResizePaneLeft:
                    serializer.Serialize(writer, "resizePaneLeft");
                    return;
                case ActionEnum.ResizePaneRight:
                    serializer.Serialize(writer, "resizePaneRight");
                    return;
                case ActionEnum.ResizePaneUp:
                    serializer.Serialize(writer, "resizePaneUp");
                    return;
                case ActionEnum.ScrollDown:
                    serializer.Serialize(writer, "scrollDown");
                    return;
                case ActionEnum.ScrollDownPage:
                    serializer.Serialize(writer, "scrollDownPage");
                    return;
                case ActionEnum.ScrollUp:
                    serializer.Serialize(writer, "scrollUp");
                    return;
                case ActionEnum.ScrollUpPage:
                    serializer.Serialize(writer, "scrollUpPage");
                    return;
                case ActionEnum.SplitHorizontal:
                    serializer.Serialize(writer, "splitHorizontal");
                    return;
                case ActionEnum.SplitPane:
                    serializer.Serialize(writer, "splitPane");
                    return;
                case ActionEnum.SplitVertical:
                    serializer.Serialize(writer, "splitVertical");
                    return;
                case ActionEnum.SwitchToTab:
                    serializer.Serialize(writer, "switchToTab");
                    return;
                case ActionEnum.SwitchToTab0:
                    serializer.Serialize(writer, "switchToTab0");
                    return;
                case ActionEnum.SwitchToTab1:
                    serializer.Serialize(writer, "switchToTab1");
                    return;
                case ActionEnum.SwitchToTab2:
                    serializer.Serialize(writer, "switchToTab2");
                    return;
                case ActionEnum.SwitchToTab3:
                    serializer.Serialize(writer, "switchToTab3");
                    return;
                case ActionEnum.SwitchToTab4:
                    serializer.Serialize(writer, "switchToTab4");
                    return;
                case ActionEnum.SwitchToTab5:
                    serializer.Serialize(writer, "switchToTab5");
                    return;
                case ActionEnum.SwitchToTab6:
                    serializer.Serialize(writer, "switchToTab6");
                    return;
                case ActionEnum.SwitchToTab7:
                    serializer.Serialize(writer, "switchToTab7");
                    return;
                case ActionEnum.SwitchToTab8:
                    serializer.Serialize(writer, "switchToTab8");
                    return;
                case ActionEnum.ToggleFullscreen:
                    serializer.Serialize(writer, "toggleFullscreen");
                    return;
            }
            throw new Exception("Cannot marshal type ActionEnum");
        }

        public static readonly ActionEnumConverter Singleton = new ActionEnumConverter();
    }

    internal class DirectionConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(Direction) || t == typeof(Direction?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "down":
                    return Direction.Down;
                case "left":
                    return Direction.Left;
                case "right":
                    return Direction.Right;
                case "up":
                    return Direction.Up;
            }
            throw new Exception("Cannot unmarshal type Direction");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (Direction)untypedValue;
            switch (value)
            {
                case Direction.Down:
                    serializer.Serialize(writer, "down");
                    return;
                case Direction.Left:
                    serializer.Serialize(writer, "left");
                    return;
                case Direction.Right:
                    serializer.Serialize(writer, "right");
                    return;
                case Direction.Up:
                    serializer.Serialize(writer, "up");
                    return;
            }
            throw new Exception("Cannot marshal type Direction");
        }

        public static readonly DirectionConverter Singleton = new DirectionConverter();
    }

    internal class SplitStateConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(SplitState) || t == typeof(SplitState?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "auto":
                    return SplitState.Auto;
                case "horizontal":
                    return SplitState.Horizontal;
                case "vertical":
                    return SplitState.Vertical;
            }
            throw new Exception("Cannot unmarshal type SplitState");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (SplitState)untypedValue;
            switch (value)
            {
                case SplitState.Auto:
                    serializer.Serialize(writer, "auto");
                    return;
                case SplitState.Horizontal:
                    serializer.Serialize(writer, "horizontal");
                    return;
                case SplitState.Vertical:
                    serializer.Serialize(writer, "vertical");
                    return;
            }
            throw new Exception("Cannot marshal type SplitState");
        }

        public static readonly SplitStateConverter Singleton = new SplitStateConverter();
    }

    internal class CommandEnumConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(CommandEnum) || t == typeof(CommandEnum?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "closePane":
                    return CommandEnum.ClosePane;
                case "closeTab":
                    return CommandEnum.CloseTab;
                case "closeWindow":
                    return CommandEnum.CloseWindow;
                case "copy":
                    return CommandEnum.Copy;
                case "copyTextWithoutNewlines":
                    return CommandEnum.CopyTextWithoutNewlines;
                case "decreaseFontSize":
                    return CommandEnum.DecreaseFontSize;
                case "duplicateTab":
                    return CommandEnum.DuplicateTab;
                case "find":
                    return CommandEnum.Find;
                case "increaseFontSize":
                    return CommandEnum.IncreaseFontSize;
                case "moveFocus":
                    return CommandEnum.MoveFocus;
                case "moveFocusDown":
                    return CommandEnum.MoveFocusDown;
                case "moveFocusLeft":
                    return CommandEnum.MoveFocusLeft;
                case "moveFocusRight":
                    return CommandEnum.MoveFocusRight;
                case "moveFocusUp":
                    return CommandEnum.MoveFocusUp;
                case "newTab":
                    return CommandEnum.NewTab;
                case "newTabProfile0":
                    return CommandEnum.NewTabProfile0;
                case "newTabProfile1":
                    return CommandEnum.NewTabProfile1;
                case "newTabProfile2":
                    return CommandEnum.NewTabProfile2;
                case "newTabProfile3":
                    return CommandEnum.NewTabProfile3;
                case "newTabProfile4":
                    return CommandEnum.NewTabProfile4;
                case "newTabProfile5":
                    return CommandEnum.NewTabProfile5;
                case "newTabProfile6":
                    return CommandEnum.NewTabProfile6;
                case "newTabProfile7":
                    return CommandEnum.NewTabProfile7;
                case "newTabProfile8":
                    return CommandEnum.NewTabProfile8;
                case "nextTab":
                    return CommandEnum.NextTab;
                case "openNewTabDropdown":
                    return CommandEnum.OpenNewTabDropdown;
                case "openSettings":
                    return CommandEnum.OpenSettings;
                case "paste":
                    return CommandEnum.Paste;
                case "prevTab":
                    return CommandEnum.PrevTab;
                case "resetFontSize":
                    return CommandEnum.ResetFontSize;
                case "resizePane":
                    return CommandEnum.ResizePane;
                case "resizePaneDown":
                    return CommandEnum.ResizePaneDown;
                case "resizePaneLeft":
                    return CommandEnum.ResizePaneLeft;
                case "resizePaneRight":
                    return CommandEnum.ResizePaneRight;
                case "resizePaneUp":
                    return CommandEnum.ResizePaneUp;
                case "scrollDown":
                    return CommandEnum.ScrollDown;
                case "scrollDownPage":
                    return CommandEnum.ScrollDownPage;
                case "scrollUp":
                    return CommandEnum.ScrollUp;
                case "scrollUpPage":
                    return CommandEnum.ScrollUpPage;
                case "splitHorizontal":
                    return CommandEnum.SplitHorizontal;
                case "splitPane":
                    return CommandEnum.SplitPane;
                case "splitVertical":
                    return CommandEnum.SplitVertical;
                case "switchToTab":
                    return CommandEnum.SwitchToTab;
                case "switchToTab0":
                    return CommandEnum.SwitchToTab0;
                case "switchToTab1":
                    return CommandEnum.SwitchToTab1;
                case "switchToTab2":
                    return CommandEnum.SwitchToTab2;
                case "switchToTab3":
                    return CommandEnum.SwitchToTab3;
                case "switchToTab4":
                    return CommandEnum.SwitchToTab4;
                case "switchToTab5":
                    return CommandEnum.SwitchToTab5;
                case "switchToTab6":
                    return CommandEnum.SwitchToTab6;
                case "switchToTab7":
                    return CommandEnum.SwitchToTab7;
                case "switchToTab8":
                    return CommandEnum.SwitchToTab8;
                case "toggleFullscreen":
                    return CommandEnum.ToggleFullscreen;
            }
            throw new Exception("Cannot unmarshal type CommandEnum");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (CommandEnum)untypedValue;
            switch (value)
            {
                case CommandEnum.ClosePane:
                    serializer.Serialize(writer, "closePane");
                    return;
                case CommandEnum.CloseTab:
                    serializer.Serialize(writer, "closeTab");
                    return;
                case CommandEnum.CloseWindow:
                    serializer.Serialize(writer, "closeWindow");
                    return;
                case CommandEnum.Copy:
                    serializer.Serialize(writer, "copy");
                    return;
                case CommandEnum.CopyTextWithoutNewlines:
                    serializer.Serialize(writer, "copyTextWithoutNewlines");
                    return;
                case CommandEnum.DecreaseFontSize:
                    serializer.Serialize(writer, "decreaseFontSize");
                    return;
                case CommandEnum.DuplicateTab:
                    serializer.Serialize(writer, "duplicateTab");
                    return;
                case CommandEnum.Find:
                    serializer.Serialize(writer, "find");
                    return;
                case CommandEnum.IncreaseFontSize:
                    serializer.Serialize(writer, "increaseFontSize");
                    return;
                case CommandEnum.MoveFocus:
                    serializer.Serialize(writer, "moveFocus");
                    return;
                case CommandEnum.MoveFocusDown:
                    serializer.Serialize(writer, "moveFocusDown");
                    return;
                case CommandEnum.MoveFocusLeft:
                    serializer.Serialize(writer, "moveFocusLeft");
                    return;
                case CommandEnum.MoveFocusRight:
                    serializer.Serialize(writer, "moveFocusRight");
                    return;
                case CommandEnum.MoveFocusUp:
                    serializer.Serialize(writer, "moveFocusUp");
                    return;
                case CommandEnum.NewTab:
                    serializer.Serialize(writer, "newTab");
                    return;
                case CommandEnum.NewTabProfile0:
                    serializer.Serialize(writer, "newTabProfile0");
                    return;
                case CommandEnum.NewTabProfile1:
                    serializer.Serialize(writer, "newTabProfile1");
                    return;
                case CommandEnum.NewTabProfile2:
                    serializer.Serialize(writer, "newTabProfile2");
                    return;
                case CommandEnum.NewTabProfile3:
                    serializer.Serialize(writer, "newTabProfile3");
                    return;
                case CommandEnum.NewTabProfile4:
                    serializer.Serialize(writer, "newTabProfile4");
                    return;
                case CommandEnum.NewTabProfile5:
                    serializer.Serialize(writer, "newTabProfile5");
                    return;
                case CommandEnum.NewTabProfile6:
                    serializer.Serialize(writer, "newTabProfile6");
                    return;
                case CommandEnum.NewTabProfile7:
                    serializer.Serialize(writer, "newTabProfile7");
                    return;
                case CommandEnum.NewTabProfile8:
                    serializer.Serialize(writer, "newTabProfile8");
                    return;
                case CommandEnum.NextTab:
                    serializer.Serialize(writer, "nextTab");
                    return;
                case CommandEnum.OpenNewTabDropdown:
                    serializer.Serialize(writer, "openNewTabDropdown");
                    return;
                case CommandEnum.OpenSettings:
                    serializer.Serialize(writer, "openSettings");
                    return;
                case CommandEnum.Paste:
                    serializer.Serialize(writer, "paste");
                    return;
                case CommandEnum.PrevTab:
                    serializer.Serialize(writer, "prevTab");
                    return;
                case CommandEnum.ResetFontSize:
                    serializer.Serialize(writer, "resetFontSize");
                    return;
                case CommandEnum.ResizePane:
                    serializer.Serialize(writer, "resizePane");
                    return;
                case CommandEnum.ResizePaneDown:
                    serializer.Serialize(writer, "resizePaneDown");
                    return;
                case CommandEnum.ResizePaneLeft:
                    serializer.Serialize(writer, "resizePaneLeft");
                    return;
                case CommandEnum.ResizePaneRight:
                    serializer.Serialize(writer, "resizePaneRight");
                    return;
                case CommandEnum.ResizePaneUp:
                    serializer.Serialize(writer, "resizePaneUp");
                    return;
                case CommandEnum.ScrollDown:
                    serializer.Serialize(writer, "scrollDown");
                    return;
                case CommandEnum.ScrollDownPage:
                    serializer.Serialize(writer, "scrollDownPage");
                    return;
                case CommandEnum.ScrollUp:
                    serializer.Serialize(writer, "scrollUp");
                    return;
                case CommandEnum.ScrollUpPage:
                    serializer.Serialize(writer, "scrollUpPage");
                    return;
                case CommandEnum.SplitHorizontal:
                    serializer.Serialize(writer, "splitHorizontal");
                    return;
                case CommandEnum.SplitPane:
                    serializer.Serialize(writer, "splitPane");
                    return;
                case CommandEnum.SplitVertical:
                    serializer.Serialize(writer, "splitVertical");
                    return;
                case CommandEnum.SwitchToTab:
                    serializer.Serialize(writer, "switchToTab");
                    return;
                case CommandEnum.SwitchToTab0:
                    serializer.Serialize(writer, "switchToTab0");
                    return;
                case CommandEnum.SwitchToTab1:
                    serializer.Serialize(writer, "switchToTab1");
                    return;
                case CommandEnum.SwitchToTab2:
                    serializer.Serialize(writer, "switchToTab2");
                    return;
                case CommandEnum.SwitchToTab3:
                    serializer.Serialize(writer, "switchToTab3");
                    return;
                case CommandEnum.SwitchToTab4:
                    serializer.Serialize(writer, "switchToTab4");
                    return;
                case CommandEnum.SwitchToTab5:
                    serializer.Serialize(writer, "switchToTab5");
                    return;
                case CommandEnum.SwitchToTab6:
                    serializer.Serialize(writer, "switchToTab6");
                    return;
                case CommandEnum.SwitchToTab7:
                    serializer.Serialize(writer, "switchToTab7");
                    return;
                case CommandEnum.SwitchToTab8:
                    serializer.Serialize(writer, "switchToTab8");
                    return;
                case CommandEnum.ToggleFullscreen:
                    serializer.Serialize(writer, "toggleFullscreen");
                    return;
            }
            throw new Exception("Cannot marshal type CommandEnum");
        }

        public static readonly CommandEnumConverter Singleton = new CommandEnumConverter();
    }

    internal class KeysConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(Keys) || t == typeof(Keys?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            switch (reader.TokenType)
            {
                case JsonToken.String:
                case JsonToken.Date:
                    var stringValue = serializer.Deserialize<string>(reader);
                    return new Keys { String = stringValue };
                case JsonToken.StartArray:
                    var arrayValue = serializer.Deserialize<List<string>>(reader);
                    return new Keys { StringArray = arrayValue };
            }
            throw new Exception("Cannot unmarshal type Keys");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            var value = (Keys)untypedValue;
            if (value.String != null)
            {
                serializer.Serialize(writer, value.String);
                return;
            }
            if (value.StringArray != null)
            {
                serializer.Serialize(writer, value.StringArray);
                return;
            }
            throw new Exception("Cannot marshal type Keys");
        }

        public static readonly KeysConverter Singleton = new KeysConverter();
    }

    internal class LaunchModeConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(LaunchMode) || t == typeof(LaunchMode?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "default":
                    return LaunchMode.Default;
                case "maximized":
                    return LaunchMode.Maximized;
            }
            throw new Exception("Cannot unmarshal type LaunchMode");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (LaunchMode)untypedValue;
            switch (value)
            {
                case LaunchMode.Default:
                    serializer.Serialize(writer, "default");
                    return;
                case LaunchMode.Maximized:
                    serializer.Serialize(writer, "maximized");
                    return;
            }
            throw new Exception("Cannot marshal type LaunchMode");
        }

        public static readonly LaunchModeConverter Singleton = new LaunchModeConverter();
    }

    internal class MinMaxValueCheckConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(double) || t == typeof(double?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<double>(reader);
            if (value >= 0 && value <= 1)
            {
                return value;
            }
            throw new Exception("Cannot unmarshal type double");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (double)untypedValue;
            if (value >= 0 && value <= 1)
            {
                serializer.Serialize(writer, value);
                return;
            }
            throw new Exception("Cannot marshal type double");
        }

        public static readonly MinMaxValueCheckConverter Singleton = new MinMaxValueCheckConverter();
    }

    internal class AntialiasingModeConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(AntialiasingMode) || t == typeof(AntialiasingMode?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "aliased":
                    return AntialiasingMode.Aliased;
                case "cleartype":
                    return AntialiasingMode.Cleartype;
                case "grayscale":
                    return AntialiasingMode.Grayscale;
            }
            throw new Exception("Cannot unmarshal type AntialiasingMode");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (AntialiasingMode)untypedValue;
            switch (value)
            {
                case AntialiasingMode.Aliased:
                    serializer.Serialize(writer, "aliased");
                    return;
                case AntialiasingMode.Cleartype:
                    serializer.Serialize(writer, "cleartype");
                    return;
                case AntialiasingMode.Grayscale:
                    serializer.Serialize(writer, "grayscale");
                    return;
            }
            throw new Exception("Cannot marshal type AntialiasingMode");
        }

        public static readonly AntialiasingModeConverter Singleton = new AntialiasingModeConverter();
    }

    internal class BackgroundImageAlignmentConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(BackgroundImageAlignment) || t == typeof(BackgroundImageAlignment?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "bottom":
                    return BackgroundImageAlignment.Bottom;
                case "bottomLeft":
                    return BackgroundImageAlignment.BottomLeft;
                case "bottomRight":
                    return BackgroundImageAlignment.BottomRight;
                case "center":
                    return BackgroundImageAlignment.Center;
                case "left":
                    return BackgroundImageAlignment.Left;
                case "right":
                    return BackgroundImageAlignment.Right;
                case "top":
                    return BackgroundImageAlignment.Top;
                case "topLeft":
                    return BackgroundImageAlignment.TopLeft;
                case "topRight":
                    return BackgroundImageAlignment.TopRight;
            }
            throw new Exception("Cannot unmarshal type BackgroundImageAlignment");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (BackgroundImageAlignment)untypedValue;
            switch (value)
            {
                case BackgroundImageAlignment.Bottom:
                    serializer.Serialize(writer, "bottom");
                    return;
                case BackgroundImageAlignment.BottomLeft:
                    serializer.Serialize(writer, "bottomLeft");
                    return;
                case BackgroundImageAlignment.BottomRight:
                    serializer.Serialize(writer, "bottomRight");
                    return;
                case BackgroundImageAlignment.Center:
                    serializer.Serialize(writer, "center");
                    return;
                case BackgroundImageAlignment.Left:
                    serializer.Serialize(writer, "left");
                    return;
                case BackgroundImageAlignment.Right:
                    serializer.Serialize(writer, "right");
                    return;
                case BackgroundImageAlignment.Top:
                    serializer.Serialize(writer, "top");
                    return;
                case BackgroundImageAlignment.TopLeft:
                    serializer.Serialize(writer, "topLeft");
                    return;
                case BackgroundImageAlignment.TopRight:
                    serializer.Serialize(writer, "topRight");
                    return;
            }
            throw new Exception("Cannot marshal type BackgroundImageAlignment");
        }

        public static readonly BackgroundImageAlignmentConverter Singleton = new BackgroundImageAlignmentConverter();
    }

    internal class BackgroundImageStretchModeConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(BackgroundImageStretchMode) || t == typeof(BackgroundImageStretchMode?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "fill":
                    return BackgroundImageStretchMode.Fill;
                case "none":
                    return BackgroundImageStretchMode.None;
                case "uniform":
                    return BackgroundImageStretchMode.Uniform;
                case "uniformToFill":
                    return BackgroundImageStretchMode.UniformToFill;
            }
            throw new Exception("Cannot unmarshal type BackgroundImageStretchMode");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (BackgroundImageStretchMode)untypedValue;
            switch (value)
            {
                case BackgroundImageStretchMode.Fill:
                    serializer.Serialize(writer, "fill");
                    return;
                case BackgroundImageStretchMode.None:
                    serializer.Serialize(writer, "none");
                    return;
                case BackgroundImageStretchMode.Uniform:
                    serializer.Serialize(writer, "uniform");
                    return;
                case BackgroundImageStretchMode.UniformToFill:
                    serializer.Serialize(writer, "uniformToFill");
                    return;
            }
            throw new Exception("Cannot marshal type BackgroundImageStretchMode");
        }

        public static readonly BackgroundImageStretchModeConverter Singleton = new BackgroundImageStretchModeConverter();
    }

    internal class CloseOnExitUnionConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(CloseOnExitUnion) || t == typeof(CloseOnExitUnion?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            switch (reader.TokenType)
            {
                case JsonToken.Boolean:
                    var boolValue = serializer.Deserialize<bool>(reader);
                    return new CloseOnExitUnion { Bool = boolValue };
                case JsonToken.String:
                case JsonToken.Date:
                    var stringValue = serializer.Deserialize<string>(reader);
                    switch (stringValue)
                    {
                        case "always":
                            return new CloseOnExitUnion { Enum = CloseOnExitEnum.Always };
                        case "graceful":
                            return new CloseOnExitUnion { Enum = CloseOnExitEnum.Graceful };
                        case "never":
                            return new CloseOnExitUnion { Enum = CloseOnExitEnum.Never };
                    }
                    break;
            }
            throw new Exception("Cannot unmarshal type CloseOnExitUnion");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            var value = (CloseOnExitUnion)untypedValue;
            if (value.Bool != null)
            {
                serializer.Serialize(writer, value.Bool.Value);
                return;
            }
            if (value.Enum != null)
            {
                switch (value.Enum)
                {
                    case CloseOnExitEnum.Always:
                        serializer.Serialize(writer, "always");
                        return;
                    case CloseOnExitEnum.Graceful:
                        serializer.Serialize(writer, "graceful");
                        return;
                    case CloseOnExitEnum.Never:
                        serializer.Serialize(writer, "never");
                        return;
                }
            }
            throw new Exception("Cannot marshal type CloseOnExitUnion");
        }

        public static readonly CloseOnExitUnionConverter Singleton = new CloseOnExitUnionConverter();
    }

    internal class CloseOnExitEnumConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(CloseOnExitEnum) || t == typeof(CloseOnExitEnum?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "always":
                    return CloseOnExitEnum.Always;
                case "graceful":
                    return CloseOnExitEnum.Graceful;
                case "never":
                    return CloseOnExitEnum.Never;
            }
            throw new Exception("Cannot unmarshal type CloseOnExitEnum");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (CloseOnExitEnum)untypedValue;
            switch (value)
            {
                case CloseOnExitEnum.Always:
                    serializer.Serialize(writer, "always");
                    return;
                case CloseOnExitEnum.Graceful:
                    serializer.Serialize(writer, "graceful");
                    return;
                case CloseOnExitEnum.Never:
                    serializer.Serialize(writer, "never");
                    return;
            }
            throw new Exception("Cannot marshal type CloseOnExitEnum");
        }

        public static readonly CloseOnExitEnumConverter Singleton = new CloseOnExitEnumConverter();
    }

    internal class CursorShapeConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(CursorShape) || t == typeof(CursorShape?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "bar":
                    return CursorShape.Bar;
                case "emptyBox":
                    return CursorShape.EmptyBox;
                case "filledBox":
                    return CursorShape.FilledBox;
                case "underscore":
                    return CursorShape.Underscore;
                case "vintage":
                    return CursorShape.Vintage;
            }
            throw new Exception("Cannot unmarshal type CursorShape");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (CursorShape)untypedValue;
            switch (value)
            {
                case CursorShape.Bar:
                    serializer.Serialize(writer, "bar");
                    return;
                case CursorShape.EmptyBox:
                    serializer.Serialize(writer, "emptyBox");
                    return;
                case CursorShape.FilledBox:
                    serializer.Serialize(writer, "filledBox");
                    return;
                case CursorShape.Underscore:
                    serializer.Serialize(writer, "underscore");
                    return;
                case CursorShape.Vintage:
                    serializer.Serialize(writer, "vintage");
                    return;
            }
            throw new Exception("Cannot marshal type CursorShape");
        }

        public static readonly CursorShapeConverter Singleton = new CursorShapeConverter();
    }

    internal class MinMaxLengthCheckConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(string);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            var value = serializer.Deserialize<string>(reader);
            if (value.Length >= 1)
            {
                return value;
            }
            throw new Exception("Cannot unmarshal type string");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            var value = (string)untypedValue;
            if (value.Length >= 1)
            {
                serializer.Serialize(writer, value);
                return;
            }
            throw new Exception("Cannot marshal type string");
        }

        public static readonly MinMaxLengthCheckConverter Singleton = new MinMaxLengthCheckConverter();
    }

    internal class ScrollbarStateConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(ScrollbarState) || t == typeof(ScrollbarState?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "hidden":
                    return ScrollbarState.Hidden;
                case "visible":
                    return ScrollbarState.Visible;
            }
            throw new Exception("Cannot unmarshal type ScrollbarState");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (ScrollbarState)untypedValue;
            switch (value)
            {
                case ScrollbarState.Hidden:
                    serializer.Serialize(writer, "hidden");
                    return;
                case ScrollbarState.Visible:
                    serializer.Serialize(writer, "visible");
                    return;
            }
            throw new Exception("Cannot marshal type ScrollbarState");
        }

        public static readonly ScrollbarStateConverter Singleton = new ScrollbarStateConverter();
    }

    internal class RequestedThemeConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(RequestedTheme) || t == typeof(RequestedTheme?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "dark":
                    return RequestedTheme.Dark;
                case "light":
                    return RequestedTheme.Light;
                case "system":
                    return RequestedTheme.System;
            }
            throw new Exception("Cannot unmarshal type RequestedTheme");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (RequestedTheme)untypedValue;
            switch (value)
            {
                case RequestedTheme.Dark:
                    serializer.Serialize(writer, "dark");
                    return;
                case RequestedTheme.Light:
                    serializer.Serialize(writer, "light");
                    return;
                case RequestedTheme.System:
                    serializer.Serialize(writer, "system");
                    return;
            }
            throw new Exception("Cannot marshal type RequestedTheme");
        }

        public static readonly RequestedThemeConverter Singleton = new RequestedThemeConverter();
    }

    internal class RowsToScrollConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(RowsToScroll) || t == typeof(RowsToScroll?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            switch (reader.TokenType)
            {
                case JsonToken.Integer:
                    var integerValue = serializer.Deserialize<long>(reader);
                    return new RowsToScroll { Integer = integerValue };
                case JsonToken.String:
                case JsonToken.Date:
                    var stringValue = serializer.Deserialize<string>(reader);
                    return new RowsToScroll { String = stringValue };
            }
            throw new Exception("Cannot unmarshal type RowsToScroll");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            var value = (RowsToScroll)untypedValue;
            if (value.Integer != null)
            {
                serializer.Serialize(writer, value.Integer.Value);
                return;
            }
            if (value.String != null)
            {
                serializer.Serialize(writer, value.String);
                return;
            }
            throw new Exception("Cannot marshal type RowsToScroll");
        }

        public static readonly RowsToScrollConverter Singleton = new RowsToScrollConverter();
    }

    internal class TabWidthModeConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(TabWidthMode) || t == typeof(TabWidthMode?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "equal":
                    return TabWidthMode.Equal;
                case "titleLength":
                    return TabWidthMode.TitleLength;
            }
            throw new Exception("Cannot unmarshal type TabWidthMode");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (TabWidthMode)untypedValue;
            switch (value)
            {
                case TabWidthMode.Equal:
                    serializer.Serialize(writer, "equal");
                    return;
                case TabWidthMode.TitleLength:
                    serializer.Serialize(writer, "titleLength");
                    return;
            }
            throw new Exception("Cannot marshal type TabWidthMode");
        }

        public static readonly TabWidthModeConverter Singleton = new TabWidthModeConverter();
    }
}
